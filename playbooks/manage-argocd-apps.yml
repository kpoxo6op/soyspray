# playbooks/manage-argocd-apps.yml
---
- name: Apply Argo CD Applications - Prepare Namespaces
  hosts: kube_control_plane
  become: true
  vars:
    kubeconfig_path: /etc/kubernetes/admin.conf
  tasks:
    - name: Ensure namespaces exist for Argo CD Applications
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ item }}"
      loop:
        - pihole  # Add more namespaces here for future applications
      loop_control:
        label: "{{ item }}"

- name: Apply Argo CD Applications - Gather Manifests
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Gather Argo CD Application manifests
      find:
        paths: "{{ playbook_dir }}/infra_configs/argocd-apps"
        patterns: "*.yaml"
        recurse: yes
      register: argo_app_files

    - name: Filter out values.yaml and non-Kubernetes files
      set_fact:
        argo_filtered_files: "{{ argo_app_files.files | selectattr('path', 'search', '^((?!values.yaml).)*$') | list }}"

    - name: Pass filtered manifests to remote hosts
      add_host:
        name: "{{ item }}"
        argo_filtered_files: "{{ argo_filtered_files }}"
      loop: "{{ groups['kube_control_plane'] }}"

- name: Apply Argo CD Applications - Deploy Applications
  hosts: kube_control_plane
  become: true
  vars:
    kubeconfig_path: /etc/kubernetes/admin.conf
  tasks:
    - name: Apply Argo CD Application manifests (deploy per namespace)
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        namespace: argocd  # ArgoCD's namespace for managing applications
        definition: "{{ lookup('file', item.path) }}"
      loop: "{{ argo_filtered_files }}"
      loop_control:
        label: "{{ item.path | basename }}"
